# input.yaml file

cutoff: 6.

data:
  filename: data_pd.gzip


potential:
  deltaSplineBins: 0.001
  elements: [H, O]  # list of all element

  # Embeddings are specified for each individual elements,
  # all parameters could be distinct for different species
  embeddings: ## possible keywords: ALL, UNARY, elements: Al, Ni
    H: {
      npot: 'FinnisSinclairShiftedScaled',
      fs_parameters: [1, 1, 1, 0.5], ## non-linear embedding function: 1*rho_1^1 + 1*rho_2^0.5
      ndensity: 2,
    }

    O: {
      npot: 'FinnisSinclairShiftedScaled', ## linear embedding function: 1*rho_1^1
      fs_parameters: [1, 1, 1, 0.5],
      ndensity: 2,
    }

  ## Bonds are specified for each possible pairs of elements
  ## One could use keywords: ALL (Al,Ni, AlNi, NiAl)
  bonds: ## possible keywords: ALL, UNARY, BINARY, elements pairs as AlAl, AlNi, NiAl, etc...  
    ALL: {
        radbase: ChebPow,
        radparameters: [5.25],

        ## outer cutoff, applied in a range [rcut - dcut, rcut]
        rcut: 6.,
        dcut: 0.01,

        ## core-repulsion parameters `prefactor` and `lambda` in
        ## prefactor*exp(-lambda*r^2)/r, >0 only r<r_in+delta_in
        #core-repulsion: [0.0, 5.0],
    }

    ## BINARY overwrites ALL settings when they are repeated
    BINARY: {
        radbase: ChebPow,
        radparameters: [6.25],

        ## cutoff may vary for different bonds
        rcut: 6.,
        dcut: 0.01,

        ## inner cutoff, applied in a range [r_in, r_in + delta_in]
        #r_in: 1.0,
        #delta_in: 0.5,

        ## core-repulsion parameters `prefactor` and `lambda` in
        ## prefactor*exp(-lambda*r^2)/r, >0 only r<r_in+delta_in
        #core-repulsion: [0.0, 5.0],
    }
  functions: # possible keywords: ALL, UNARY, BINARY, TERNARY, QUATERNARY, QUINARY, element combinations as (Al,Al), (Al, Ni), (Al, Ni, Zn), etc...
  
   ALL: {
      nradmax_by_orders: [12, 6, 3, 1, 1],
      lmax_by_orders: [0, 5, 3, 2, 1],
      # coefs_init: zero # initialization of functions coefficients: zero (default) or random
    }


  ## possible keywords: ALL, UNARY, BINARY, TERNARY, QUATERNARY, QUINARY,
  ##  element combinations as (Al,Al), (Al, Ni), (Al, Ni, Zn), etc...

fit:
    ## LOSS FUNCTION OPTIONS ##
    loss: {
      ## [0..1] or auto, relative force weight,
      ## kappa = 0 - energies-only fit,
      ## kappa = 1 - forces-only fit
      ## auto - determined from dataset based on variance of energies and forces
      kappa: 0.33,
      ## L1-regularization coefficient
      L1_coeffs: 0.00000000001,
      ## L2-regularization coefficient
      L2_coeffs: 0.00000000001,
      w1_coeffs: 1.0,
      w2_coeffs: 1.0,
      ## w0 radial smoothness regularization coefficient
      w0_rad: 0.0000001,
      ## w1 radial smoothness regularization coefficient
      w1_rad: 0.0000001,
      ## w2 radial smoothness regularization coefficient
      w2_rad: 0.0000001
    }

    ## DATA WEIGHTING OPTIONS ##
    weighting: {
        ## weights for the structures energies/forces are associated according to the distance to E_min:
        ## convex hull ( energy: convex_hull) or minimal energy per atom (energy: cohesive)
        type: EnergyBasedWeightingPolicy,
        ## number of structures to randomly select from the initial dataset
        #nfit: 10000,         
        ## only the structures with energy up to E_min + DEup will be selected
        DEup: 10000.0,  ## eV, upper energy range (E_min + DElow, E_min + DEup)        
        ## only the structures with maximal force on atom  up to DFup will be selected
        DFup: 5000.0, ## eV/A
        ## lower energy range (E_min, E_min + DElow)
        #DElow: 1.0,  ## eV
        ## delta_E  shift for weights, see paper
        #DE: 1.0,
        ## delta_F  shift for weights, see paper
        #DF: 1.0,
        ## 0<wlow<1 or None: if provided, the renormalization weights of the structures on lower energy range (see DElow)
        #wlow: 0.75,        
        ##  "convex_hull" or "cohesive" : method to compute the E_min
        energy: convex_hull,        
        ## structures types: all (default), bulk or cluster
        reftype: all,        
        ## random number seed
        seed: 42 
    }

    ## Custom weights:  corresponding to main dataset index and `w_energy` and `w_forces` columns should
    ## be provided in pckl.gzip file
    #weighting: {type: ExternalWeightingPolicy, filename: custom_weights_only.pckl.gzip}

    ## OPTIMIZATION OPTIONS ##
    optimizer: BFGS # BFGS, L-BFGS-B, Nelder-Mead, etc. : scipy minimization algorithm
    ## additional options for scipy.minimize(..., options={...}, ...)
    #options: {maxcor: 100}    
    maxiter: 200 # maximum number of iteration for EACH scipy minimization round

    ## EXTRA OPTIONS ##
    repulsion: auto            # set inner cutoff based on the minimal distance in the dataset

    trainable_parameters: ALL  # ALL, UNARY, BINARY, ..., radial, func, {"AlNi": "func"}, {"AlNi": {"func","radial"}}, ...

    ##(optional) number of consequentive runs of fitting algorithm (for each ladder step), that helps convergence
    fit_cycles: 1   

    ## starting from second fit_cycle:

    ## applies Gaussian noise with specified relative sigma/mean ratio to all potential trainable coefficients
    #noise_relative_sigma: 1e-3

    ## applies Gaussian noise with specified absolute sigma to all potential trainable coefficients
    #noise_absolute_sigma: 1e-3  

    # reset the function coefficients according to Gaussian distribution with given sigma; enable ensemble fitting mode
    #randomize_func_coeffs: 1e-3  

    ## LADDER SCHEME (i.e. hierarchical fitting) ##      
    ## enables hierarchical fitting (LADDER SCHEME), that sequentially add specified number of B-functions (LADDER STEP)    
    ladder_step: [200, 0.02]  
    ##      - integer >= 1 - number of basis functions to add in ladder scheme,
    ##      - float between 0 and 1 - relative ladder step size wrt. current basis step
    ##      - list of both above values - select maximum between two possibilities on each iteration 
    ##     see. Ladder scheme fitting for more info


    ## Possible values:
    ## body_order  -  new basis functions are added according to the body-order, i.e., a function with higher body-order
    ##                will not be added until the list of functions of the previous body-order is exhausted
    ## power_order -  the order of adding new basis functions is defined by the "power rank" p of a function.
    ##                p = len(ns) + sum(ns) + sum(ls). Functions with the smallest p are added first      
    ladder_type: power_order   


    ## callbacks during the fitting. Module quick_validation.py should be available for import
    ## see example/pacemaker_with_callback for more details and examples
    #callbacks:
    #  - quick_validation.test_fcc_potential_callback
backend:
  evaluator: tensorpot  # pyace, tensorpot

 ## for `tensorpot` evaluator, following options are available:
  batch_size: 200            # batch size for loss function evaluation, default is 10
  batch_size_reduction: True # automatic batch_size reduction if not enough memory (default - True) 
  batch_size_reduction_factor: 1.618  # batch size reduction factor
  display_step: 50          # frequency of detailed metric calculation and printing
 
 ## for `pyace` evaluator, following options are available:
 # parallel_mode: process    # process, serial  - parallelization mode for `pyace` evaluator
 # n_workers: 4              # number of parallel workers for `process` parallelization mode
#  gpu_config: {gpu_ind: 1, mem_limit: 0}
